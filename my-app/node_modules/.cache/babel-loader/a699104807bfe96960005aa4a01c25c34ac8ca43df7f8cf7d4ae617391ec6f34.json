{"ast":null,"code":"var _jsxFileName = \"G:\\\\Coding\\\\KATOMARAN-HACKATHON\\\\my-app\\\\src\\\\components\\\\assets\\\\livestream\\\\livestream.jsx\",\n  _s = $RefreshSig$();\n// import React, { useEffect, useRef, useState } from \"react\";\n\n// const LiveStream = () => {\n//   const videoRef = useRef(null);\n//   const canvasRef = useRef(null);\n//   const [streaming, setStreaming] = useState(false);\n\n//   useEffect(() => {\n//     startCamera();\n//     const interval = setInterval(() => {\n//       if (streaming) {\n//         captureAndSendFrame();\n//       }\n//     }, 1000); // Send frame every 1s\n\n//     return () => {\n//       stopCamera();\n//       clearInterval(interval);\n//     };\n//   }, [streaming]);\n\n//   const startCamera = async () => {\n//     try {\n//       const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n//       videoRef.current.srcObject = stream;\n//       setStreaming(true);\n//     } catch (err) {\n//       console.error(\"Camera error:\", err);\n//     }\n//   };\n\n//   const stopCamera = () => {\n//     if (videoRef.current && videoRef.current.srcObject) {\n//       const tracks = videoRef.current.srcObject.getTracks();\n//       tracks.forEach(track => track.stop());\n//     }\n//     setStreaming(false);\n//   };\n\n//   const captureAndSendFrame = async () => {\n//     const video = videoRef.current;\n//     const canvas = canvasRef.current;\n//     if (!video || !canvas) return;\n\n//     const context = canvas.getContext(\"2d\");\n//     context.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n//     const dataURL = canvas.toDataURL(\"image/jpeg\");\n\n//     try {\n//       const res = await fetch(\"http://localhost:5000/recognize\", {\n//         method: \"POST\",\n//         headers: { \"Content-Type\": \"application/json\" },\n//         body: JSON.stringify({ image: dataURL }),\n//       });\n\n//       const data = await res.json();\n//       drawBoxes(data.faces);\n//     } catch (err) {\n//       console.error(\"Recognition error:\", err);\n//     }\n//   };\n\n//   const drawBoxes = (faces) => {\n//     const canvas = canvasRef.current;\n//     const ctx = canvas.getContext(\"2d\");\n\n//     ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n//     for (let face of faces) {\n//       const { left, top, right, bottom, name } = face;\n//       ctx.strokeStyle = \"green\";\n//       ctx.lineWidth = 2;\n//       ctx.strokeRect(left, top, right - left, bottom - top);\n\n//       ctx.fillStyle = \"green\";\n//       ctx.fillRect(left, top - 20, ctx.measureText(name).width + 10, 20);\n\n//       ctx.fillStyle = \"white\";\n//       ctx.font = \"16px Arial\";\n//       ctx.fillText(name, left + 5, top - 5);\n//     }\n//   };\n\n//   return (\n//     <div>\n//       <h2>Live Face Recognition</h2>\n//       <div style={{ position: \"relative\", width: \"640px\", height: \"480px\" }}>\n//         <video\n//           ref={videoRef}\n//           autoPlay\n//           muted\n//           width=\"640\"\n//           height=\"480\"\n//           style={{ position: \"absolute\", zIndex: 1 }}\n//         />\n//         <canvas\n//           ref={canvasRef}\n//           width=\"640\"\n//           height=\"480\"\n//           style={{ position: \"absolute\", zIndex: 2 }}\n//         />\n//       </div>\n//     </div>\n//   );\n// };\n\n// export default LiveStream;\nimport React, { useRef, useEffect, useState } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction LiveStream() {\n  _s();\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  const [faceMemory, setFaceMemory] = useState({});\n  const [streaming, setStreaming] = useState(true);\n  const canvasWidth = 640;\n  const canvasHeight = 480;\n  useEffect(() => {\n    let stream = null;\n    let intervalId = null;\n    const stopCamera = () => {\n      if (videoRef.current && videoRef.current.srcObject) {\n        videoRef.current.srcObject.getTracks().forEach(track => track.stop());\n        videoRef.current.srcObject = null;\n        setStreaming(false);\n      }\n    };\n    const startCamera = async () => {\n      try {\n        stream = await navigator.mediaDevices.getUserMedia({\n          video: true\n        });\n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n          await videoRef.current.play();\n          setStreaming(true);\n        }\n        intervalId = setInterval(captureAndRecognize, 800);\n      } catch (err) {\n        console.error(\"Camera error:\", err);\n      }\n    };\n    const captureAndRecognize = async () => {\n      if (!videoRef.current || !canvasRef.current || document.hidden) return;\n      const video = videoRef.current;\n      const canvas = canvasRef.current;\n      const ctx = canvas.getContext(\"2d\");\n\n      // Draw current video frame\n      ctx.drawImage(video, 0, 0, canvasWidth, canvasHeight);\n\n      // Convert canvas to base64\n      const dataUrl = canvas.toDataURL(\"image/jpeg\");\n      try {\n        const response = await fetch(\"http://localhost:5000/recognize\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            image: dataUrl\n          })\n        });\n        const result = await response.json();\n\n        // Redraw fresh frame\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        ctx.drawImage(video, 0, 0, canvasWidth, canvasHeight);\n\n        // Update face memory\n        let newMemory = {\n          ...faceMemory\n        };\n        const now = Date.now();\n        result.faces.forEach(({\n          top,\n          right,\n          bottom,\n          left,\n          name\n        }) => {\n          const key = `${left}_${top}_${right}_${bottom}`;\n          newMemory[key] = {\n            name,\n            coords: {\n              top,\n              right,\n              bottom,\n              left\n            },\n            timestamp: now\n          };\n        });\n\n        // Remove stale memory\n        Object.keys(newMemory).forEach(key => {\n          if (now - newMemory[key].timestamp > 2000) {\n            delete newMemory[key];\n          }\n        });\n        setFaceMemory(newMemory);\n\n        // Draw bounding boxes and names\n        Object.values(newMemory).forEach(({\n          name,\n          coords\n        }) => {\n          const {\n            top,\n            right,\n            bottom,\n            left\n          } = coords;\n\n          // Draw bounding box\n          ctx.strokeStyle = \"#00FF00\";\n          ctx.lineWidth = 2;\n          ctx.strokeRect(left, top, right - left, bottom - top);\n\n          // Draw label background\n          const label = name;\n          const textWidth = ctx.measureText(label).width;\n          const padding = 4;\n          ctx.fillStyle = \"#00FF00\";\n          ctx.fillRect(left, top - 24, textWidth + padding * 2, 20);\n\n          // Draw label text\n          ctx.fillStyle = \"#000000\";\n          ctx.font = \"16px Arial\";\n          ctx.fillText(label, left + padding, top - 8);\n        });\n      } catch (error) {\n        console.error(\"Recognition error:\", error);\n      }\n    };\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        clearInterval(intervalId);\n        stopCamera();\n      } else {\n        if (!streaming) {\n          startCamera();\n        }\n      }\n    };\n    startCamera();\n    document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n    return () => {\n      clearInterval(intervalId);\n      stopCamera();\n      document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n    };\n  }, [faceMemory]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      position: \"relative\",\n      width: canvasWidth,\n      height: canvasHeight\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      width: canvasWidth,\n      height: canvasHeight,\n      muted: true,\n      style: {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        zIndex: 1,\n        display: \"none\"\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 240,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: canvasWidth,\n      height: canvasHeight,\n      style: {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        zIndex: 2\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 247,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 239,\n    columnNumber: 5\n  }, this);\n}\n_s(LiveStream, \"o8ptER/p9i4EB1a4o05ef30mpKk=\");\n_c = LiveStream;\nexport default LiveStream;\nvar _c;\n$RefreshReg$(_c, \"LiveStream\");","map":{"version":3,"names":["React","useRef","useEffect","useState","jsxDEV","_jsxDEV","LiveStream","_s","videoRef","canvasRef","faceMemory","setFaceMemory","streaming","setStreaming","canvasWidth","canvasHeight","stream","intervalId","stopCamera","current","srcObject","getTracks","forEach","track","stop","startCamera","navigator","mediaDevices","getUserMedia","video","play","setInterval","captureAndRecognize","err","console","error","document","hidden","canvas","ctx","getContext","drawImage","dataUrl","toDataURL","response","fetch","method","headers","body","JSON","stringify","image","result","json","clearRect","newMemory","now","Date","faces","top","right","bottom","left","name","key","coords","timestamp","Object","keys","values","strokeStyle","lineWidth","strokeRect","label","textWidth","measureText","width","padding","fillStyle","fillRect","font","fillText","handleVisibilityChange","clearInterval","addEventListener","removeEventListener","style","position","height","children","ref","muted","zIndex","display","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["G:/Coding/KATOMARAN-HACKATHON/my-app/src/components/assets/livestream/livestream.jsx"],"sourcesContent":["// import React, { useEffect, useRef, useState } from \"react\";\r\n\r\n// const LiveStream = () => {\r\n//   const videoRef = useRef(null);\r\n//   const canvasRef = useRef(null);\r\n//   const [streaming, setStreaming] = useState(false);\r\n\r\n//   useEffect(() => {\r\n//     startCamera();\r\n//     const interval = setInterval(() => {\r\n//       if (streaming) {\r\n//         captureAndSendFrame();\r\n//       }\r\n//     }, 1000); // Send frame every 1s\r\n\r\n//     return () => {\r\n//       stopCamera();\r\n//       clearInterval(interval);\r\n//     };\r\n//   }, [streaming]);\r\n\r\n//   const startCamera = async () => {\r\n//     try {\r\n//       const stream = await navigator.mediaDevices.getUserMedia({ video: true });\r\n//       videoRef.current.srcObject = stream;\r\n//       setStreaming(true);\r\n//     } catch (err) {\r\n//       console.error(\"Camera error:\", err);\r\n//     }\r\n//   };\r\n\r\n//   const stopCamera = () => {\r\n//     if (videoRef.current && videoRef.current.srcObject) {\r\n//       const tracks = videoRef.current.srcObject.getTracks();\r\n//       tracks.forEach(track => track.stop());\r\n//     }\r\n//     setStreaming(false);\r\n//   };\r\n\r\n//   const captureAndSendFrame = async () => {\r\n//     const video = videoRef.current;\r\n//     const canvas = canvasRef.current;\r\n//     if (!video || !canvas) return;\r\n\r\n//     const context = canvas.getContext(\"2d\");\r\n//     context.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n\r\n//     const dataURL = canvas.toDataURL(\"image/jpeg\");\r\n\r\n//     try {\r\n//       const res = await fetch(\"http://localhost:5000/recognize\", {\r\n//         method: \"POST\",\r\n//         headers: { \"Content-Type\": \"application/json\" },\r\n//         body: JSON.stringify({ image: dataURL }),\r\n//       });\r\n\r\n//       const data = await res.json();\r\n//       drawBoxes(data.faces);\r\n//     } catch (err) {\r\n//       console.error(\"Recognition error:\", err);\r\n//     }\r\n//   };\r\n\r\n//   const drawBoxes = (faces) => {\r\n//     const canvas = canvasRef.current;\r\n//     const ctx = canvas.getContext(\"2d\");\r\n\r\n//     ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n//     for (let face of faces) {\r\n//       const { left, top, right, bottom, name } = face;\r\n//       ctx.strokeStyle = \"green\";\r\n//       ctx.lineWidth = 2;\r\n//       ctx.strokeRect(left, top, right - left, bottom - top);\r\n\r\n//       ctx.fillStyle = \"green\";\r\n//       ctx.fillRect(left, top - 20, ctx.measureText(name).width + 10, 20);\r\n\r\n//       ctx.fillStyle = \"white\";\r\n//       ctx.font = \"16px Arial\";\r\n//       ctx.fillText(name, left + 5, top - 5);\r\n//     }\r\n//   };\r\n\r\n//   return (\r\n//     <div>\r\n//       <h2>Live Face Recognition</h2>\r\n//       <div style={{ position: \"relative\", width: \"640px\", height: \"480px\" }}>\r\n//         <video\r\n//           ref={videoRef}\r\n//           autoPlay\r\n//           muted\r\n//           width=\"640\"\r\n//           height=\"480\"\r\n//           style={{ position: \"absolute\", zIndex: 1 }}\r\n//         />\r\n//         <canvas\r\n//           ref={canvasRef}\r\n//           width=\"640\"\r\n//           height=\"480\"\r\n//           style={{ position: \"absolute\", zIndex: 2 }}\r\n//         />\r\n//       </div>\r\n//     </div>\r\n//   );\r\n// };\r\n\r\n// export default LiveStream;\r\nimport React, { useRef, useEffect, useState } from \"react\";\r\n\r\nfunction LiveStream() {\r\n  const videoRef = useRef(null);\r\n  const canvasRef = useRef(null);\r\n  const [faceMemory, setFaceMemory] = useState({});\r\n  const [streaming, setStreaming] = useState(true);\r\n\r\n  const canvasWidth = 640;\r\n  const canvasHeight = 480;\r\n\r\n  useEffect(() => {\r\n    let stream = null;\r\n    let intervalId = null;\r\n\r\n    const stopCamera = () => {\r\n      if (videoRef.current && videoRef.current.srcObject) {\r\n        videoRef.current.srcObject.getTracks().forEach(track => track.stop());\r\n        videoRef.current.srcObject = null;\r\n        setStreaming(false);\r\n      }\r\n    };\r\n\r\n    const startCamera = async () => {\r\n      try {\r\n        stream = await navigator.mediaDevices.getUserMedia({ video: true });\r\n        if (videoRef.current) {\r\n          videoRef.current.srcObject = stream;\r\n          await videoRef.current.play();\r\n          setStreaming(true);\r\n        }\r\n\r\n        intervalId = setInterval(captureAndRecognize, 800);\r\n      } catch (err) {\r\n        console.error(\"Camera error:\", err);\r\n      }\r\n    };\r\n\r\n    const captureAndRecognize = async () => {\r\n      if (!videoRef.current || !canvasRef.current || document.hidden) return;\r\n\r\n      const video = videoRef.current;\r\n      const canvas = canvasRef.current;\r\n      const ctx = canvas.getContext(\"2d\");\r\n\r\n      // Draw current video frame\r\n      ctx.drawImage(video, 0, 0, canvasWidth, canvasHeight);\r\n\r\n      // Convert canvas to base64\r\n      const dataUrl = canvas.toDataURL(\"image/jpeg\");\r\n\r\n      try {\r\n        const response = await fetch(\"http://localhost:5000/recognize\", {\r\n          method: \"POST\",\r\n          headers: { \"Content-Type\": \"application/json\" },\r\n          body: JSON.stringify({ image: dataUrl }),\r\n        });\r\n\r\n        const result = await response.json();\r\n\r\n        // Redraw fresh frame\r\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n        ctx.drawImage(video, 0, 0, canvasWidth, canvasHeight);\r\n\r\n        // Update face memory\r\n        let newMemory = { ...faceMemory };\r\n        const now = Date.now();\r\n\r\n        result.faces.forEach(({ top, right, bottom, left, name }) => {\r\n          const key = `${left}_${top}_${right}_${bottom}`;\r\n          newMemory[key] = { name, coords: { top, right, bottom, left }, timestamp: now };\r\n        });\r\n\r\n        // Remove stale memory\r\n        Object.keys(newMemory).forEach(key => {\r\n          if (now - newMemory[key].timestamp > 2000) {\r\n            delete newMemory[key];\r\n          }\r\n        });\r\n\r\n        setFaceMemory(newMemory);\r\n\r\n        // Draw bounding boxes and names\r\n        Object.values(newMemory).forEach(({ name, coords }) => {\r\n          const { top, right, bottom, left } = coords;\r\n\r\n          // Draw bounding box\r\n          ctx.strokeStyle = \"#00FF00\";\r\n          ctx.lineWidth = 2;\r\n          ctx.strokeRect(left, top, right - left, bottom - top);\r\n\r\n          // Draw label background\r\n          const label = name;\r\n          const textWidth = ctx.measureText(label).width;\r\n          const padding = 4;\r\n          ctx.fillStyle = \"#00FF00\";\r\n          ctx.fillRect(left, top - 24, textWidth + padding * 2, 20);\r\n\r\n          // Draw label text\r\n          ctx.fillStyle = \"#000000\";\r\n          ctx.font = \"16px Arial\";\r\n          ctx.fillText(label, left + padding, top - 8);\r\n        });\r\n      } catch (error) {\r\n        console.error(\"Recognition error:\", error);\r\n      }\r\n    };\r\n\r\n    const handleVisibilityChange = () => {\r\n      if (document.hidden) {\r\n        clearInterval(intervalId);\r\n        stopCamera();\r\n      } else {\r\n        if (!streaming) {\r\n          startCamera();\r\n        }\r\n      }\r\n    };\r\n\r\n    startCamera();\r\n    document.addEventListener(\"visibilitychange\", handleVisibilityChange);\r\n\r\n    return () => {\r\n      clearInterval(intervalId);\r\n      stopCamera();\r\n      document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\r\n    };\r\n  }, [faceMemory]);\r\n\r\n  return (\r\n    <div style={{ position: \"relative\", width: canvasWidth, height: canvasHeight }}>\r\n      <video\r\n        ref={videoRef}\r\n        width={canvasWidth}\r\n        height={canvasHeight}\r\n        muted\r\n        style={{ position: \"absolute\", top: 0, left: 0, zIndex: 1, display: \"none\" }}\r\n      />\r\n      <canvas\r\n        ref={canvasRef}\r\n        width={canvasWidth}\r\n        height={canvasHeight}\r\n        style={{ position: \"absolute\", top: 0, left: 0, zIndex: 2 }}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default LiveStream;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}